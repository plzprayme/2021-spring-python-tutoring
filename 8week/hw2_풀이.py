# -*- coding: utf-8 -*-
"""HW2_풀이.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UQWjDQ_BrGE28W_dahPUVZ-vBTFCkFt-

# HNU CE Python Programming (2021 1학기) HW2
- 이름:
- 학번:


다양한 정렬 알고리듬을 작성해 보는 것도 프로그래밍의 기초를 익히는 데 좋은 공부가 되지만
실제 활용에서는 자신이 원하는 기준으로 자유자재로 정렬할 줄 아는 것이 매우 중요하다.
이런 것을 확실히 짚고 넘어가자는 의미에서 출제된 과제이다.

----
## 문제 1. 정렬 기준을 설정할 수 있도록 merge_sort 함수 변경 (5점)
수업시간에`merge_sort`를 bottom-up 방식으로 작성한 코드를 그대로 가져다 놓았다.
현재 `merge_sort(xs)`와 같이 리스트 인자를 넘기는 하나의 파라미터만으로 정의된 함수를
변경하여 `merge_sort(xs,key=func)`와 같이 키워드 파라미터에 `func` 함수로 넘겨주어
정렬 기준을 필요에 따라 바꿔서 설정할 수 있게 하라. `func`가 `lambda x: x`일 때,
즉 `merge_sort(xs,key=(lambda x: x))`일 때 기본 정렬기준으로 (그러니까 변형하기 전과 똑같이) 동작해야 한다.

참고로 주요 알고리듬은 `msort` 함수에 작성되어 있고 `merge_sort`는 데이터를 
적절이 변환하여 `msort`를 호출하며, 또 `msort`는 `merge` 함수를 호출해
정렬된 부분 리스트들을 병합한다. 그러므로 `merge_sort` 뿐만 아니라
`msort`와 `merge` 함수도 변경해야 할 수 있다.

`msort`는 2중 리스트 즉 리스트를 원소 포함하는 리스트를
받아 원소 리스트를 계속 합병해 2중 리스트 안에 하나의 리스트 원소만 남을 때까지 합병.

```
   msort( [ [4], [2], [1], [3] ] )
=> msort( [ [2,4], [1,3] ] ) 
=> msort( [ [1,2,3,4] ] )
=> [ [1,2,3,4] ]
```

`msort(xss)`를 정의하기 위한 알고리즘
 - 반복조건 `len(xss) > 1`:
     - xss의 원소들을 두개씩 merge한 리스트로 재귀호출.
     - 단, 리스트의 길이가 홀수여서 마지막에 원소가 짝이 맞지 않아 합병할 수 없으면 그대로 둔다.
 - 종료조건 `len(xss) == 1`: xss를 그대로 리턴
"""

def merge_sort(xs, key):
    try:
      key(0)
      key = ascending
    except TypeError:
      pass


    xss = [ [x] for x in xs ] # 리스트 조건제시법 list comperehension

    [ss] = msort(xss, key)
    return ss

def msort(xss, key): # bottom-up이라 알고리즘 정의대로 작성하면 자연스럽게 꼬리재귀가 된다
    if len(xss) > 1:
        value = msort( [ merge(xss[i],xss[i+1], key) if i+1 < len(xss) else xss[i]
                          for i in range(0,len(xss),2) ], key )
        return value
    else:
        return xss

def merge(left,right, key): # 실습 5.9: merge 함수 while 버전
    ss = []
    while not (left == [] or right == []): # 비어 있으면 반복하지 않는다.
        if key(left[0], right[0]):
            ss.append( left[0] )  # 끝에 원소 하나 붙이기
            left = left[1:]
        else:
            ss.append( right[0] ) # 끝에 원소 하나 붙이기
            right = right[1:]

    ss.extend(left)  # 끝에 리스트 연장
    ss.extend(right) # 끝에 리스트 연장
    return ss

ascending = lambda l, r: l <= r
illegal = lambda x: x

def test_helper(odd_list, even_list, case, sort_by):
  print(case)
  print(merge_sort( odd_list, sort_by))
  print(merge_sort( even_list, sort_by))
  print("=" * 60)

even_list = [4,2,1,3]
odd_list = [4,2,1,3,5]

test_helper(odd_list, even_list, "<오름차순>", ascending)
test_helper(odd_list, even_list,"<lambda x: x도 호환 가능>", illegal)

"""----
## 문제 2. 정수를 증가하지 않는 순서로 정렬 (2점)
위에서 변형한 `merge_sort`를 활용하는 문제이다.

`xs`가 정수 리스트일 때 `merge_sort(xs,key=func)`의 결과가
기본 정렬 순서와 반대로 순서로 (즉, 증가하지 않는 순서, 그러니까 가장 큰 정수가 맨 앞으로)
정렬되도록 하고 싶다. 예컨대,
```
   merge_sort([1,3,2,4],key=func)
=> [4,3,2,1]
```

키워드 파라미터 `key`에 인수로 제공할 적절한 함수 `func`가 무엇이 되어야 할지
생각하고, 원하는 대로 동작하는지 테스트를 작성해 보라.

"""

descending = lambda l, r: l >= r

even_list = [4,2,1,3]
odd_list = [4,2,1,3,5]


test_helper(odd_list, even_list, "<내림차순>", descending)

"""----
## 문제 3. 순서쌍을 둘째 원소를 우선 정렬 (3점)
위에서 변형한 `merge_sort`를 활용하는 문제이다.

`xs`가 순서쌍(즉, 크기 2인 튜플)진 리스트일 때 `merge_sort(xs,key=func)`의 결과가
기본 정렬 순서인 첫째 원소 우선이 아닌 둘째 원소 우선으로 정렬되도록 하고 싶다. 참고로 
우선적인 원소가 같아서 순서를 가릴 수 없으면 나머지 원소를 비교해 순서를 매긴다. 예컨대,
```
   merge_sort([(3,'b'),(4,'a'),(1,'b'),(2,'c')],key=func)
=> [(4,'a'),(1,'b'),(3,'b'),(2,'c')]
```
위의 예에서 `(3,'b')`와 `(1,'b')`는 둘째 원소로만 순서를 가릴 수 없어
첫째 원소를 비교했을 때 `1 <= 3`이므로 `(1,'b')`가 `(3,'b')`보다 앞서게 된다.


키워드 파라미터 `key`에 인수로 제공할 적절한 함수 `func`가 무엇이 되어야 할지
생각하고, 원하는 대로 동작하는지 테스트를 작성해 보라.
"""

def hw3(l, r):
  if l[1] == r[1]:
    return l[0] <= r[0]
  else:
    return l[1] < r[1]

print("문제 3번")
print(merge_sort([(3,'b'),(4,'a'),(1,'b'),(2,'c')],key=hw3))
print(merge_sort([(3,'b'),(4,'a'),(1,'b'),(2,'c'), (1, 'c')],key=hw3))

"""----
## 문제 4. 문자열을 사전순과 반대 순서로 정렬 (4점)
마찬가지로 위에서 변형한 `merge_sort`를 활용하는 문제이다.

`xs`가 문자열 리스트일 때 `merge_sort(xs,key=func)`의 결과가
기본 정렬와 반대로, 즉 사전순의 역순으로 정렬되도록 하고 싶다. 예컨대,
```
   merge_sort(['apple','orange','bannana', 'beer'],key=func)
=> ['orange','beer','bannana','apple']
```

키워드 파라미터 `key`에 인수로 제공할 적절한 함수 `func`가 무엇이 되어야 할지
생각하고, 원하는 대로 동작하는지 테스트를 작성해 보라.

"""

print(merge_sort(['apple','orange','bannana', 'beer'], key=lambda l, r: l > r))
print(merge_sort(['apple','orange','bannana', 'beer', 'cass'], key=lambda l, r: l > r))

"""----
## 문제 5. 정수와 문자열이 섞여 있는 리스트의 정렬 (5점)
위에서 변형한 `merge_sort`를 활용하는 문제이다.

`xs`가 정수와 문자열이 동시에 포함된 리스트일 때
`merge_sort(xs,key=func)`의 결과가 정수는 모두 문자열보다 앞에 오도록 하고
정수와 문자열끼리는 기본 정렬 순서대로 정렬되도록 하고 싶다.
예컨대,
```
   merge_sort([1,3,'orange',2,'bannana','apple'],key=func)
=> [1,2,3,'apple','bannana','orange']
```

키워드 파라미터 `key`에 인수로 제공할 적절한 함수 `func`가 무엇이 되어야 할지
생각하고, 원하는 대로 동작하는지 테스트를 작성해 보라.

"""

def hw5(l, r):
  if type(l) == type(r):
    return l < r
  else:
    if type(l) == type(1):
      return True
    return False

merge_sort([1,3,'orange',2,'bannana','apple'],key=hw5)
merge_sort([1,3,'orange',2,'bannana','apple', 'aa'],key=hw5)

